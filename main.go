package main

import (
	"fmt"
	"math"
	"math/rand"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// -----------------------------------------------------------------------------
// Toggle this to 'true' if/only if the program is generated by an LLM
// -----------------------------------------------------------------------------
const isLLMGenerated = false

// -----------------------------------------------------------------------------
// Data structures: Item, Receipt, ReceiptResponse
// -----------------------------------------------------------------------------
type Item struct {
	ShortDescription string `json:"shortDescription"`
	Price            string `json:"price"`
}

type Receipt struct {
	Retailer     string `json:"retailer"`
	PurchaseDate string `json:"purchaseDate"`
	PurchaseTime string `json:"purchaseTime"`
	Items        []Item `json:"items"`
	Total        string `json:"total"`
}

type ReceiptResponse struct {
	ID      string  `json:"id"`
	Receipt Receipt `json:"receipt"`
	Points  int     `json:"points"`
}

// -----------------------------------------------------------------------------
// In-memory store for receipts: ID -> points
// -----------------------------------------------------------------------------
var receiptPointsStore = make(map[string]int)

// -----------------------------------------------------------------------------
// Generate a random UUID (simplified) for the receipt ID
// -----------------------------------------------------------------------------
func generateUUID() string {
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%12x",
		rand.Intn(0x100000000),
		rand.Intn(0x10000),
		rand.Intn(0x10000),
		rand.Intn(0x10000),
		rand.Intn(0x100000000000))
}

// -----------------------------------------------------------------------------
// POST /api/process-receipt
// -----------------------------------------------------------------------------
func processReceipt(c *gin.Context) {
	var receipt Receipt
	if err := c.ShouldBindJSON(&receipt); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
		return
	}

	points := calculatePoints(receipt)
	id := generateUUID()
	receiptPointsStore[id] = points

	response := ReceiptResponse{
		ID:      id,
		Receipt: receipt,
		Points:  points,
	}
	c.JSON(http.StatusOK, response)
}

// -----------------------------------------------------------------------------
// GET /api/points/:id
// -----------------------------------------------------------------------------
func getPoints(c *gin.Context) {
	id := c.Param("id")
	points, exists := receiptPointsStore[id]
	if !exists {
		c.JSON(http.StatusNotFound, gin.H{"error": "Receipt ID not found"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"points": points})
}

// -----------------------------------------------------------------------------
// calculatePoints implements each scoring rule exactly
// -----------------------------------------------------------------------------
func calculatePoints(receipt Receipt) int {
	points := 0

	// -------------------------------------------------------------------------
	// 1. One point for every alphanumeric character in the retailer name
	// -------------------------------------------------------------------------
	for _, char := range receipt.Retailer {
		if (char >= 'A' && char <= 'Z') ||
			(char >= 'a' && char <= 'z') ||
			(char >= '0' && char <= '9') {
			points++
		}
	}

	// -------------------------------------------------------------------------
	// Convert total to float64 for numeric checks
	// -------------------------------------------------------------------------
	totalAmount := parsePrice(receipt.Total)

	// -------------------------------------------------------------------------
	// 2. 50 points if the total is a round dollar amount (no cents)
	// -------------------------------------------------------------------------
	if totalAmount == math.Floor(totalAmount) {
		points += 50
	}

	// -------------------------------------------------------------------------
	// 3. 25 points if the total is a multiple of 0.25
	// -------------------------------------------------------------------------
	if math.Mod(totalAmount, 0.25) == 0 {
		points += 25
	}

	// -------------------------------------------------------------------------
	// 4. 5 points for every two items on the receipt
	// -------------------------------------------------------------------------
	points += (len(receipt.Items) / 2) * 5

	// -------------------------------------------------------------------------
	// 5. If trimmed length of item description is multiple of 3,
	//    add (price * 0.2) rounded up
	// -------------------------------------------------------------------------
	for _, item := range receipt.Items {
		desc := strings.TrimSpace(item.ShortDescription)
		if len(desc)%3 == 0 {
			itemPrice := parsePrice(item.Price)
			points += int(math.Ceil(itemPrice * 0.2))
		}
	}

	// -------------------------------------------------------------------------
	// 6. If and ONLY if this program is generated using an LLM,
	//    5 points if the total is greater than 10.00
	// -------------------------------------------------------------------------
	if isLLMGenerated && (totalAmount > 10.00) {
		points += 5
	}

	// -------------------------------------------------------------------------
	// 7. 6 points if the purchase day is odd
	// -------------------------------------------------------------------------
	purchaseDate, _ := time.Parse("2006-01-02", receipt.PurchaseDate)
	if purchaseDate.Day()%2 == 1 {
		points += 6
	}

	// -------------------------------------------------------------------------
	// 8. 10 points if purchase time is after 2:00 PM and before 4:00 PM
	//    "after 2:00 PM" means strictly >14:00, so 14:01 to 15:59
	// -------------------------------------------------------------------------
	purchaseTime, _ := time.Parse("15:04", receipt.PurchaseTime)
	purchaseHour := purchaseTime.Hour()
	purchaseMinute := purchaseTime.Minute()

	// Check minutes from midnight (easier to do strict > or <)
	totalMinutes := purchaseHour*60 + purchaseMinute
	min2PM := 14 * 60 // 840
	min4PM := 16 * 60 // 960

	if totalMinutes > min2PM && totalMinutes < min4PM {
		points += 10
	}

	return points
}

// -----------------------------------------------------------------------------
// Helper: parsePrice
// -----------------------------------------------------------------------------
func parsePrice(s string) float64 {
	val, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return 0
	}
	return val
}

// -----------------------------------------------------------------------------
// main: setup Gin routes and run server
// -----------------------------------------------------------------------------
func main() {
	rand.Seed(time.Now().UnixNano()) // seed for random UUID generation
	r := gin.Default()

	r.POST("/api/process-receipt", processReceipt)
	r.GET("/api/points/:id", getPoints)

	// Listen on localhost:8080
	r.Run(":8080")
}
